\subsection*{Geo-Informations-Grundlagen}

In addition to the usual mainly structural breakdown of
elements, there are more complex functions and non-functional
requirements that depend on many different submodels and
model elements. An example of a comprehensive function
is smoke detection, which cannot be assigned to one single
system part. Such functions are problematic for the traditional
requirements-based design process, which follows a functional
breakdown and leads to many individual components that
solve their tasks independently. For example, there are many
different communication systems designed and installed inside
today’s aircraft purely because there is no global view on
the communication needs of all subsystems. This leads to
unnecessary amounts of cabling weights and costs, and higher
maintenance efforts.
On the other hand, there are many non-functional requirements such as weight, cost, reliability and so on, which
govern the search for a “good” system design. A quality
function (or cost / profit function) has to be defined that takes
into account all significant non-functional requirements. This
function can then be evaluated for a certain parameterization of
the executable model to compare, for instance, different system
architectures or spare part logistics operation methods.
Based on an executable model, the designer can evaluate
which decisions are necessary to reach a superordinated design
goal. It is possible to analyse the global effects of changing
a local component, which is especially important because an
improvement in a local system may be counterproductive when
viewing the system as a whole.
Design based on an executable model, i.e., model-based
design in the sense used in this paper, has the potential to
increase the design productivity significantly. To avoid flaws
at architectural level, models serve as executable specifications already in the early design phases. As such they are
closely related to the system requirements, describing functional, behavioral, and quantitative demands. Simulation allows
checking the behavior and consistency of the top-down system
model with the requirements long before the integration tests.
Moreover, there is a global view on the results of local design
decisions.
Compared with the standard requirements-based design, the
following advantages have been summarized in the literature [5], among others:
• Analysis of dynamic behavior of a system is possible
during the early design phases already.
• Design decision can be based on simulation and evaluation of alternatives, and typical trade-offs (such as reliability vs. investment costs) between conflicting effects on
system performance can be balanced.
• The model is used at different levels of design.
• It is possible to model and validate non-functional properties.
A. Model-Based Design With MLDesigner
We propose to use the software tool MLDesigner, see also
[6], which has been implemented for the design of complex
systems at mission and system level. The tool supports an
approach integrating architecture, functions, behavioral specifications, and application scenarios in one unifying development
environment.
MLDesigner includes a several models of computation
such as discrete event (DE), synchronous data flow (SDF),
continuous time (CT), and finite state machines (FSM), and
contains a multi-domain simulation, consequently. Different
models of computation can be mixed in one hierarchical model.
Another technique is to model the overall system using a mixed
signal description language, see [7]. Complex systems can
be described in an efficient way by reusing modules and by
instantiating submodels from the huge set of application-area
specific libraries. Currently there are more than 2000 library
blocks available in the supported five models of computation.
The modeler is free to decide from and to which level of detail
the system should be specified.
\begin{figure}%[tbhp]
    \centering
    \includegraphics[width=.8\linewidth]{images/Logo_Informatik}
    \caption{Screen shot of MLDesigners Graphical User Interface}
    \label{fig:REPLACE}
\end{figure}

The tool has a standard graphical user interface as shown
in Fig. 1, in the example screen shot with menu and tool bars
as well as some windows. Starting at the upper left corner
there is the main menu, tool bars, the data structure editor, add
member function, console, design window, parameter set and
parameter editor, as well as the tree view of the hierarchical
model. The design window is the main drawing area of the
tool, in which model components are added and modified. The
design window in the example screen shot shows a simulation
model that is ready for execution. Models are constructed
as hierarchical block diagrams. Function blocks may contain
models and thus connected blocks at a lower level of detail, or
they are primitives at the lowest refinement level. Primitives
are predefined or user-supplied algorithms with well-defined
input and output ports. Their behavior is implemented in a
specially formatted C++ code. Input and output ports of each
block are depicted by small triangles, which can be connected
by lines to specify the flow of data or execution (in the model
of computation shown).
For a comparison of MLDesigner with other tools in the
area of system modeling, the reader is referred to [8].